Explanation of heuristic:
Given state:
>>>>>>>>>>
AB
C

>>>>>>>>>>

Goal state:
>>>>>>>>>>
A
CB

>>>>>>>>>>

To calculate h(n) for a given state I iterate over all the blocks and count how many blocks in the given state match the blocks in the goal state. I then subtract this number from the total number of blocks. In this example, h(n) would be 1. Because there are 3 blocks in total and 2 blocks that are in the same position as in the goal state (the A and C blocks). 3 - 2 = 1.

Summary of heuristic:
I tried 2 different heuristics, the one mentioned above, as well as one that returned the total number of blocks minus the given state's maximum number of matching blocks among its successors. The latter heuristic was much slower in terms of time, as it had to iterate over all the successors, and it was much less successful at solving the problems.
The heuristic I used solved 24 out of 45 problems in 100,000 iterations. There was not one problem that was found to not have a solution. The only reason any of the problems were not solved was because they took too long.
With a few exceptions, the problems that were able to be solved were solved rather quickly. Of the 24 problems that were solved, 19 of them were solved in under 1000 iterations.
The amount of iterations and the seeming difficulty of the problems increased with the number of blocks in the problem. It was interesting to see that the number of iterations to solve a problem did not correlate much with the number of stacks. You can see in graph_1.png the average number of blocks and stacks for problems that were solved and those that weren't. They have a similar average number of stacks, but the problems that were unsolved had a much higher average number of blocks.
This idea is further illustrated by graph_2.png where we can see a clear increase in the average number of iterations with an increase in the number of blocks.
As far as I used and tested this solution, it did not ever find a clearly suboptimal path.
We can see in graph_3.png that the average number of goal tests and max queue size rose sharply with larger solution path lengths.
